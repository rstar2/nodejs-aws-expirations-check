# Welcome to Serverless!
#
# See https://github.com/AnomalyInnovations/serverless-stack-demo-api

service: my-expirations-check

custom:
  # define the name of the DynamoDB Table here as it's ARN will be used in the IAM roles also
  expirationsTable: ${self:service}-${self:provider.stage}-expirations
  apiLambdaFunction: ${self:service}-${self:provider.stage}-api

plugins:
  - serverless-iam-roles-per-function

provider:
  name: aws
  profile: serverless-cli
  runtime: nodejs8.10

  stage: ${opt:stage, 'dev'}
  region: ${file(env.yml):env.AWS_REGION} # Note this env.AWS_REGION SHOULD NOT be set as environment variable

  # 'iamRoleStatement' defines the permission policy for the Lambda function.
  # In this case Lambda functions are granted with permissions to access DynamoDB.
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:DescribeTable
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      # allow access to ONLY the needed DynamoDB Table - better design
      # Resource: "arn:aws:dynamodb:${self:provider.region}:*:table:${self:custom.expirationsTable}"
      Resource:
        - "Fn::GetAtt": [ ExpirationsTable, Arn ]
      # allow access to ALL DynamoDB Tables
      # Resource: "arn:aws:dynamodb:${self:provider.region}:*:*"

    - Effect: "Allow"
      Action:
        - "ses:SendEmail"
      Resource: ["*"]
  
  # Load environment variables externally from 'env.yml' depending on the stage,
  # Fallback to default if it is not in specified stage.
  environment: ${file(env.yml):${self:provider.stage}, file(env.yml):default}

functions:
  - check:
      handler: handler.check
      events:
        - http:
            path: check
            method: GET
            cors: true
            # authorizer: aws_iam
        # - schedule: rate(10 minutes) # Run every 10 minutes
        - schedule: cron(15 8 * * ? *) # Run at 8:15 am (UTC) every day

  - api:
      handler: handler.api
      events:
        - http:
            path: list
            method: GET
            cors: true
            # authorizer: aws_iam
        - http:
            path: add
            method: POST
            cors: true
            # authorizer: aws_iam
        - http:
            path: delete
            method: POST
            cors: true
            # authorizer: aws_iam 

  - webapp:
      handler: webapp/lambda.handler
      timeout: 30
      events:
        # all routes get proxied to the Express router
        - http: ANY /
          cors: true
        - http: 'ANY {proxy+}'
          cors: true
      # provide these env vars to the function as she'll need it
      environment:
        AWS_STAGE: ${self:provider.stage}
        AWS_LAMBDA_API: ${self:custom.apiLambdaFunction}
      
      # Using the 'serverless-iam-roles-per-function' plugin we can
      # easily define IAM roles per function
      iamRoleStatementsInherit: true
      iamRoleStatements:
        - Effect: Allow
          Action:
            - lambda:InvokeFunction
          # allow invoking all functions  
          # Resource: "*"

          # allow invoking just the handler.api function
          Resource: "arn:aws:lambda:${self:provider.region}:*:function:${self:custom.apiLambdaFunction}"
                  # "arn:aws:lambda:${self:provider.region}:${self:provider.environment.AWS_ACCOUNT}:function:${self:service}-${self:provider.stage}-lambdaTwo"  
      
# you can add CloudFormation resource templates here
resources:
  # DynamoDB
  - ${file(dynamodb-table.yml)}
