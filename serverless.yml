# Welcome to Serverless!
#
# See https://github.com/AnomalyInnovations/serverless-stack-demo-api

service: my-expirations-check

custom:
  # define the name of the DynamoDB Table here as it's ARN will be used in the IAM roles also
  expirationsTable: ${self:service}-${self:provider.stage}-expirations
  apiLambdaFunction: ${self:service}-${self:provider.stage}-api
  apiLambdaFunctionSecret: ${file(env.yml):env.AWS_LAMBDA_API_SECRET}

  # implementing custom authorization
  authorizer:
    user:
      name: authorizerUser
      type: TOKEN
      identitySource: method.request.header.Authorization
      identityValidationExpression: Bearer (.*)
      resultTtlInSeconds: 1

plugins:
  - serverless-iam-roles-per-function
  - serverless-offline

package:
  exclude:
    - .vscode/**
    - cli/**
    - tests/**
    - '**/__mocks__/**'
    - webapp/node_modules/**
    - webapp/public-src/**
    - webapp/app-local.js
    - webapp/package-lock.json
    - webapp/package.json
    - webapp/webpack.config.js

provider:
  name: aws
  profile: serverless-cli
  runtime: nodejs8.10

  stage: ${opt:stage, 'dev'}
  region: ${file(env.yml):env.AWS_REGION} # Note this env.AWS_REGION SHOULD NOT be set as environment variable

  # 'iamRoleStatement' defines the permission policy for the Lambda function.
  # In this case Lambda functions are granted with permissions to access DynamoDB.
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:DescribeTable
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      # allow access to ONLY the needed DynamoDB Table - better design
      # Resource: "arn:aws:dynamodb:${self:provider.region}:*:table:${self:custom.expirationsTable}"
      Resource:
        - "Fn::GetAtt": [ ExpirationsTable, Arn ]
      # allow access to ALL DynamoDB Tables
      # Resource: "arn:aws:dynamodb:${self:provider.region}:*:*"

    - Effect: "Allow"
      Action:
        - "ses:SendEmail"
      Resource: ["*"]
  
  # Load environment variables externally from 'env.yml' depending on the stage,
  # Fallback to default if it is not in specified stage.
  environment: ${file(env.yml):${self:provider.stage}, file(env.yml):default}

functions:
  # the custom authorizer function (that's placed before a API Gateway event)
  - authorizerUser:
      handler: handlers/authorizer.handler
      # provide these env vars to the function as she'll need it
      environment:
        JWT_SECRET: ${file(env.yml):env.JWT_SECRET}

  - check:
      handler: handlers/check.handler
      events:
        - http:
            path: api/check
            method: GET
            cors: true
            authorizer: aws_iam
            # authorizer: ${self:custom.authorizer.user}
        # - schedule: rate(10 minutes) # Run every 10 minutes
        - schedule: cron(15 8 * * ? *) # Run at 8:15 am (UTC) every day
  
  - api:
      handler: handlers/api.handler
      events:
        - http:
            path: api/list
            method: GET
            cors: true
            authorizer: aws_iam
            # authorizer: ${self:custom.authorizer.user}
        - http:
            path: api/add
            method: POST
            cors: true
            authorizer: aws_iam
            # authorizer: ${self:custom.authorizer.user}
        - http:
            path: api/delete
            method: POST
            cors: true
            authorizer: aws_iam
            # authorizer: ${self:custom.authorizer.user}
        - http:
            path: api/update
            method: POST
            cors: true
            authorizer: aws_iam
            # authorizer: ${self:custom.authorizer.user}

      # provide these env vars to the function as she'll need it
      environment:
        AWS_LAMBDA_API_SECRET: ${self:custom.apiLambdaFunctionSecret}

  - webapp:
      handler: handlers/webapp.handler
      timeout: 30
      events:
        # all routes get proxied to the Express router
        - http:
            method: ANY
            path: /invoke/api/{action+}
            cors: true
            # authorizer: aws_iam
            authorizer: ${self:custom.authorizer.user}  
        - http: 
            path: / # this matches the base path
            method: ANY
            cors: true
        - http:
            path: /{any+}  # this matches any path, the token 'any' doesn't mean anything special. Note it's greedy path parameter (The + sign indicates whichever child resources are appended to it)
            method: ANY
            cors: true
          
      # provide these env vars to the function as she'll need it
      environment:
        AWS_STAGE: ${self:provider.stage}
        AWS_LAMBDA_API: ${self:custom.apiLambdaFunction}
        AWS_LAMBDA_API_SECRET: ${self:custom.apiLambdaFunctionSecret}
        # AWS_PROFILE will allow to uing the serverless-offline plugin and thus 'aws-sdk' will have  proper auth credentials,
        # apart from that it's not used 
        AWS_PROFILE: ${file(env.yml):env.AWS_PROFILE}
        JWT_SECRET: ${file(env.yml):env.JWT_SECRET}
      
      # Using the 'serverless-iam-roles-per-function' plugin we can
      # easily define IAM roles per function
      iamRoleStatementsInherit: true
      iamRoleStatements:
        - Effect: Allow
          Action:
            - lambda:InvokeFunction
          # allow invoking all functions  
          # Resource: "*"

          # allow invoking just the handler.api function
          Resource: "arn:aws:lambda:${self:provider.region}:*:function:${self:custom.apiLambdaFunction}"
                  # "arn:aws:lambda:${self:provider.region}:${self:provider.environment.AWS_ACCOUNT}:function:${self:service}-${self:provider.stage}-lambdaTwo"  
      
# you can add CloudFormation resource templates here
resources:
  # DynamoDB
  - ${file(dynamodb-table.yml)}
